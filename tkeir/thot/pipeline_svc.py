# -*- coding: utf-8 -*-
"""Convert source document to tkeir indexer document
Author : Eric Blaudez (Eric Blaudez)

Copyright (c) 2022 THALES 
All Rights Reserved.
"""
from sanic import Sanic
from sanic.exceptions import ServerError
import sanic.response
from sanic.exceptions import NotFound
import threading

import os
import sys
import argparse
import traceback
import gc
import time
from multiprocessing import shared_memory
from uuid import uuid4


dir_path = os.path.dirname(os.path.realpath(__file__))
sys.path.insert(0, os.path.abspath(os.path.join(dir_path, "../../")))
sys.path.insert(0, os.path.abspath(os.path.join(dir_path, "../")))
sys.path.insert(0, os.path.abspath(os.path.join(dir_path, "./")))

from thot import __author__, __copyright__, __credits__, __maintainer__, __email__, __status__
import thot.core.Constants as Constants
from thot.core.ThotLogger import ThotLogger, LogUserContext
from thot.core.ThotMetrics import ThotMetrics
from thot.core.Utils import generate_id, type_to_bool
from thot.tasks.taggers_pipeline import __version_pipeline__, __date_pipeline__
from thot.tasks.taggers_pipeline.TaggersPipelineConfiguration import TaggersPipelineConfiguration
from thot.tasks.taggers_pipeline.TaggersPipeline import TaggersPipeline, pipelineLoop

x_served_by = "tkeir/pipeline"

# Global variables
app = Sanic("pipline-service")
app.config["API_VERSION"] = __version_pipeline__
app.config["API_TITLE"] = "pipeline Service"
app.config["API_DESCRIPTION"] = "Tokenize document in tkeir format (generally coming from converter service)"
app.config["API_CONTACT_EMAIL"] = __email__


class PipelineEngine:
    """Store pipeline as singleton
    Warning args should be set before calls
    """

    pipeline = None
    pipelineConfiguration = None
    args = None
    count_run = 0

    @staticmethod
    def get_config():
        """create an return configuration as singleton

        Returns:
            pipelineConfiguration: return the pipeline configuration load through args
        """
        if not PipelineEngine.pipelineConfiguration:
            PipelineEngine.pipelineConfiguration = TaggersPipelineConfiguration()
            with open(PipelineEngine.args.config) as fh:
                PipelineEngine.pipelineConfiguration.load(fh)
                fh.close()
        return PipelineEngine.pipelineConfiguration

    @staticmethod
    def getpipeline():
        """create and return pipeline as singleton

        Returns:
            pipeline:  return the pipeline
        """
        if not PipelineEngine.pipeline:
            PipelineEngine.pipeline = TaggersPipeline(config=PipelineEngine.get_config())
        return PipelineEngine.pipeline

    @staticmethod
    def reloadAt(max_count):
        PipelineEngine.count_run = PipelineEngine.count_run + 1
        if PipelineEngine.count_run > max_count:
            PipelineEngine.count_run = 0
            del PipelineEngine.pipeline
            gc.collect()
            PipelineEngine.pipeline = TaggersPipeline(config=PipelineEngine.get_config())
            ThotLogger.info("Free memory, prevent memory leak")


pipeline_engine = None


def service_config():
    app.config.update(
        {
            "CONFIGURATION_FILE": PipelineEngine.args.config,
        }
    )
    app.config["FALLBACK_ERROR_FORMAT"] = "json"


def service_not_loaded(call_context):
    call_context["status"] = 500
    ThotLogger.error("Service is not loaded", context=call_context)
    return sanic.response.json(
        {"error": Constants.SERVICE_NOT_LOADED, "version": __version_pipeline__, "date": __date_pipeline__},
        headers={"X-Served-By": x_served_by},
        status=500,
    )


@app.listener("before_server_start")
async def setup_config(app, loop):
    service_config()


@app.listener("after_server_start")
def init(sanic, loop):
    global pipeline_engine
    pipeline_engine = {
        "id": generate_id(prefix="pipeline"),
        "ppid": os.getppid(),
        "pid": os.getpid(),
        "run": PipelineEngine.getpipeline(),
    }
    ThotLogger.info("Service loaded")


def sanic_bad_parameter_response(error_description):
    return sanic.response.json(
        {
            "error": error_description,
            "info": pipeline_engine["id"],
            "config": app.config["CONFIGURATION_FILE"],
            "version": __version_pipeline__,
            "date": __date_pipeline__,
        },
        headers={"X-Served-By": x_served_by},
        status=422,
    )


@app.route("/api/pipeline/run", methods=["POST", "OPTIONS"])
async def run_service(request):
    no_x_correlation = "autogenerated-" + str(uuid4())
    cid = request.headers.get("x-correlation-id") or no_x_correlation
    log_context = LogUserContext(cid)
    if not pipeline_engine:
        ThotMetrics.increment_counter(short_name="pipeline-run", path="/api/pipeline/run", method="post", status=500)
        return service_not_loaded(log_context)
    try:
        if "action" in request.json:
            warning_action = ""
            if request.json["action"] == "start":
                pipeline_engine["run"].start_upload()
            elif request.json["action"] == "finish":
                pipeline_engine["run"].finish_upload()
            else:
                warning_action = "Undefined action"
            ThotMetrics.increment_counter(short_name="pipeline-run", path="/api/pipeline/run", method="post", status=200)
            return sanic.response.json(
                {
                    "warning": warning_action,
                    "info": pipeline_engine["id"],
                    "config": app.config["CONFIGURATION_FILE"],
                    "version": __version_pipeline__,
                    "date": __date_pipeline__,
                },
                headers={"X-Served-By": x_served_by},
                status=200,
            )
        if "datatype" not in request.json:
            return sanic_bad_parameter_response("datatype is mandatory")
        if "data" not in request.json:
            return sanic_bad_parameter_response("data is mandatory")
        if "source" not in request.json:
            return sanic_bad_parameter_response("source is mandatory")
        ThotLogger.info("Run " + request.json["source"], context=log_context)
        token_data = pipeline_engine["run"].upload(
            data_type=request.json["datatype"],
            data=request.json["data"],
            source=request.json["source"],
            call_context=log_context,
        )
        if not token_data:
            ThotMetrics.increment_counter(short_name="pipeline-run", path="/api/pipeline/run", method="post", status=503)
            return sanic.response.json(
                {
                    "error": "upload not started",
                    "info": pipeline_engine["id"],
                    "config": app.config["CONFIGURATION_FILE"],
                    "version": __version_pipeline__,
                    "date": __date_pipeline__,
                },
                headers={"X-Served-By": x_served_by},
                status=503,
            )
        ThotMetrics.increment_counter(short_name="pipeline-run", path="/api/pipeline/run", method="post", status=200)
        return sanic.response.json(
            {
                "token-id": token_data,
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=200,
        )
    except Exception as e:
        ThotMetrics.increment_counter(short_name="pipeline-run", path="/api/pipeline/run", method="post", status=500)
        ThotLogger.error(
            "Exception occured.",
            trace=Constants.exception_error_and_trace(str(e), str(traceback.format_exc())),
            context=log_context,
        )
        return sanic.response.json(
            {
                "error": Constants.SERVICE_INTERNAL_ERROR,
                "exception": str(e),
                "trace": str(traceback.format_exc()),
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=500,
        )


@app.route("/api/pipeline/status", methods=["POST", "OPTIONS"])
async def status_service(request):
    no_x_correlation = "autogenerated-" + str(uuid4())
    cid = request.headers.get("x-correlation-id") or no_x_correlation
    log_context = LogUserContext(cid)
    if not pipeline_engine:
        ThotMetrics.increment_counter(short_name="pipeline-status", path="/api/pipeline/status", method="post", status=500)
        return service_not_loaded(log_context)
    try:
        if "token-id" not in request.json:
            return sanic_bad_parameter_response("token-id is mandatory")

        token_status = pipeline_engine["run"].status(request.json["token-id"])
        ThotMetrics.increment_counter(short_name="pipeline-status", path="/api/pipeline/status", method="post", status=200)
        return sanic.response.json(
            {
                "token-status": token_status,
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=200,
        )
    except Exception as e:
        ThotMetrics.increment_counter(short_name="pipeline-status", path="/api/pipeline/status", method="post", status=500)
        ThotLogger.error(
            "Exception occured.",
            trace=Constants.exception_error_and_trace(str(e), str(traceback.format_exc())),
            context=log_context,
        )
        return sanic.response.json(
            {
                "error": Constants.SERVICE_INTERNAL_ERROR,
                "exception": str(e),
                "trace": str(traceback.format_exc()),
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=500,
        )


@app.route("/api/pipeline/get", methods=["POST", "OPTIONS"])
async def get_document(request):
    no_x_correlation = "autogenerated-" + str(uuid4())
    cid = request.headers.get("x-correlation-id") or no_x_correlation
    log_context = LogUserContext(cid)
    if not pipeline_engine:
        ThotMetrics.increment_counter(short_name="pipeline-get", path="/api/pipeline/get", method="post", status=500)
        return service_not_loaded(log_context)
    token_status = ""
    data = ""
    try:
        if "token-id" not in request.json:
            ThotMetrics.increment_counter(short_name="pipeline-get", path="/api/pipeline/get", method="post", status=500)
            return sanic_bad_parameter_response("token-id is mandatory")
        token_status = pipeline_engine["run"].status(request.json["token-id"])
        data = ""
        if "is-last-task" in token_status:
            data = pipeline_engine["run"].get(request.json["token-id"])
            token_status = "ready"
        if not data:
            token_status = "processing"
        ThotMetrics.increment_counter(short_name="pipeline-get", path="/api/pipeline/get", method="post", status=200)
        return sanic.response.json(
            {
                "token-status": token_status,
                "results": data,
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=200,
        )

    except Exception as e:
        ThotMetrics.increment_counter(short_name="pipeline-get", path="/api/pipeline/get", method="post", status=500)
        ThotLogger.error(
            "Exception occured.",
            trace=Constants.exception_error_and_trace(str(e), str(traceback.format_exc())),
            context=log_context,
        )
        return sanic.response.json(
            {
                "error": Constants.SERVICE_INTERNAL_ERROR,
                "exception": str(e),
                "trace": str(traceback.format_exc()),
                "info": pipeline_engine["id"],
                "config": app.config["CONFIGURATION_FILE"],
                "version": __version_pipeline__,
                "date": __date_pipeline__,
            },
            headers={"X-Served-By": x_served_by},
            status=500,
        )


@app.route("/api/pipeline/health", methods=["GET", "POST", "OPTIONS"])
async def health(request):
    no_x_correlation = "autogenerated-" + str(uuid4())
    cid = request.headers.get("x-correlation-id") or no_x_correlation
    log_context = LogUserContext(cid)
    if not pipeline_engine:
        ThotMetrics.increment_counter(short_name="pipeline-health", path="/api/pipeline/health", method="get", status=500)
        return service_not_loaded(log_context)
    ThotMetrics.increment_counter(short_name="pipeline-health", path="/api/pipeline/health", method="get", status=200)
    return sanic.response.json(
        {
            "health": Constants.SERVICE_HEALTH_OK,
            "info": pipeline_engine["id"],
            "config": app.config["CONFIGURATION_FILE"],
            "version": __version_pipeline__,
            "date": __date_pipeline__,
        },
        headers={"X-Served-By": x_served_by},
        status=200,
    )


@app.exception(NotFound)
async def function_not_found(request, exception):
    no_x_correlation = "autogenerated-" + str(uuid4())
    cid = request.headers.get("x-correlation-id") or no_x_correlation
    log_context = LogUserContext(cid)
    if not pipeline_engine:
        ThotMetrics.increment_counter(short_name="pipeline-health", path="/api/pipeline/health", method="get", status=500)
        return service_not_loaded(log_context)
    ThotMetrics.increment_counter(short_name="pipeline-health", path="/api/pipeline/health", method="get", status=200)
    return sanic.response.json(
        {
            "error": Constants.SERVICE_PAGE_NOT_FOUND,
            "info": pipeline_engine["id"],
            "config": app.config["CONFIGURATION_FILE"],
            "version": __version_pipeline__,
            "date": __date_pipeline__,
        },
        headers={"X-Served-By": x_served_by},
        status=404,
    )


@app.route("/metrics", methods=["GET", "POST", "OPTIONS"])
async def metrics(request):
    output = ThotMetrics.generateMetricsResponse().decode("utf-8")
    content_type = ThotMetrics.METRIC_MIME_TYPE
    return sanic.response.text(body=output, content_type=content_type)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--config", default=None, type=str, help="configuration file")
    parser.add_argument("-w", "--workers", default=1, type=int, help="number of workers for the service")
    parser.add_argument("-ns", "--no-server", action="store_true", help="do not use server")
    args = parser.parse_args()
    PipelineEngine.args = args
    if not PipelineEngine.args.config:
        ThotLogger.loads()
        ThotLogger.error("Configuration file is mandatory")
        sys.exit(-1)

    try:
        ThotLogger.loads(PipelineEngine.get_config().logger_config.configuration)
        ThotMetrics.APP_NAME = "T-KEIR : pipeline"
        ThotMetrics.create_counter(
            short_name="pipeline-health", function_name="health", counter_description="Health function count"
        )
        ThotMetrics.create_counter(short_name="pipeline-run", function_name="run", counter_description="run function count")
        ThotMetrics.create_counter(short_name="pipeline-get", function_name="get", counter_description="Get function count")
        ThotMetrics.create_counter(
            short_name="pipeline-status", function_name="status", counter_description="Status function count"
        )
        host = PipelineEngine.get_config().net_config.configuration["network"]["host"]
        port = int(PipelineEngine.get_config().net_config.configuration["network"]["port"])
        PipelineEngine.getpipeline()
        processThread = None
        workers = args.workers
        if PipelineEngine.get_config().configuration["settings"]["strategy"] != "monolithic":
            ThotLogger.info("On non-monolithic pipeline the number of worker is force to 1.")
            workers = 1
        try:
            ThotLogger.info("Start loop threading")
            log_context = LogUserContext("pipeline-server-ctx")
            processThread = threading.Thread(
                target=pipelineLoop,
                args=(
                    PipelineEngine.pipeline,
                    log_context,
                ),
            )
            processThread.start()
            time.sleep(1)
        except:
            ThotLogger.info("Does not duplication pipeline loop")
        if not args.no_server:
            use_ssl = os.getenv("TKEIR_USE_SSL", "True")
            if ("ssl" in PipelineEngine.get_config().net_config.configuration["network"]) and type_to_bool(use_ssl):
                ThotLogger.info("Run service with SSL")
                app.run(
                    host=host,
                    port=port,
                    workers=workers,
                    ssl=PipelineEngine.get_config().net_config.configuration["network"]["ssl"],
                )
            else:
                app.run(host=host, port=port, workers=workers)
            if processThread:
                PipelineEngine.pipeline.stop()
                processThread.join()
        else:
            processThread.join()
    except KeyboardInterrupt as kbe:
        PipelineEngine.getpipeline().stop()
        processThread.join()
    except Exception as e:
        PipelineEngine.pipeline.stop()
        ThotLogger.error("An error occured.", trace=Constants.exception_error_and_trace(str(e), str(traceback.format_exc())))
        sys.exit(-1)


if __name__ == "__main__":    
    main()
